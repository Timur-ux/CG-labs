\documentclass[pdf, unicode, 12pt, a4paper,oneside,fleqn]{article}

\newcommand{\labNumber}{1}
\newcommand{\commitDate}[1][\today]{#1}
\newcommand{\theme}{Основы 2D-графики и трансформаций\\}
\newcommand{\task}{В данной лабораторной работе вам предстоит научиться работать с графическим API для  отрисовки 2D-примитивов, освоить основные 2D-трансформации (перемещение, масштабирование, поворот) и изучить алгоритмы построения 2D-кривых.

Требования: Вы должны использовать С++ (OpenGL + SFML) или C\# (OpenTK).

Программа должна работать в реальном времени, обновляя изображение в цикле.

Визуальный результат необходимо продемонстрировать на экране с возможностью управления через интерфейс.\\}
\newcommand{\variantNumber}{11. Анимация по траектории кривой Безье}
\newcommand{\variantTask}{Реализуйте анимацию движения объекта (например, круга) по траектории кривой Безье.

Анимация должна быть плавной, объект должен перемещаться по кривой с равномерной скоростью.

Добавьте управление скоростью анимации через интерфейс.

Дополнительно: Реализуйте изменение размера объекта в зависимости от его положения
на кривой.\\}
\newcommand{\decision}{Кривую Безье зададим вектором опорных точек. (Все координаты будем задавать в нормализованном виде, т.е. на отрезке [-1, 1], это значительно упростит вершинный шейдер). Далее в классе кривой Безье опишем важный метод получения точки на данной кривой во время $t \in [0, 1]$. С её помощью мы будем отрисовывать кривую и расчитывать положение объекта на кривой.

\textit{Построение кривой Безье: } В конструктор кривой Безье прокидывется в качестве параметра степень детализации, т.е. количество рассчитываемых точек для отрисовки. Для хранения данных о координатах заведем буфер вершин(vbo), чтобы хранить координаты прямо в памяти видеокарты. Далее указываем, что у нас там хранятся именно координаты (переменная вершиного шейдера с индексом 0) через функцию glVertexAttribPointer. Для хранения состояния vbo создадим объект вершинного массива(vao). Собственно, конструкция кривой Безье происходит следующим образом: расчитываем n равномерно расположенных на кривой точек, где n -- степень детализации. Далее создается и привязывается vao, vbo. На vbo кладутся рассчитанные координаты, вызывается glVertexAttribPointer. После этого у нас готовы данные для отрисовки кривой Безье.

\textit{Построение объекта на кривой Безье: } В качестве объекта я выбрал прямоугольник, т.к. у него простейшая геометрия(всего 2 треугольника). Ситуация аналогичная построению кривой Безье: рассчет координат точек, vao, vbo, glVertexAttribPointer. Единственное отличие в том, что объект будет перемещаться, т.е. на каждом кадре у него надо будет пересчитывать координаты и соответственно обновлять оные на GPU. В общем для этого после каждого расчета нужно вызывать glBufferData, для vbo прямоугольника.  

\textit{Отрисовка: } Для отрисовки достаточно прикрепить соответствующий vao и шейдерную программу и вызвать glDrawArrays, которая принимает в качестве аргументов тип отрисовываемого примитива, с какого начинать и количество отрисовываемых вершин. Для кривой Безье в качестве типа указываем GL\_LINE\_STRIP(Ломанная линия), для квадрата -- GL\_TRIANGLE\_FAN(Треугольники с общей вершиной, позволяет задать квадрат всего 4 точками, вместо 6 для обычного GL\_TRIANGLES).

\textit{GUI: } Для управления скоростью перемещения я буду использовать систему событий(она без особых наворотов описана в файле events.hpp). Для кнопок будем использовать цветные прямоугольники подписанные на событие нажатия на экран. Каждая кнопка будет иметь собственный обработчик, один для ускорения, другой для замедления.

\textit{Шейдерные программы: } На момент описания первой лабы я еще плохо разбирался в шейдерах, поэтому использовал самый примитивный вариант. Для вершинного шейдера -- проброс входной координаты в фрагментный шейдер без преобразования, во фрагментном шейдере просто задается фрагменту один цвет. Сообственно для красного, зеленого и синего цветов я использовал отдельные шейдеры.

\textit{Изменение размера объекта: } Мне показалась прикольной идей задавать ширину и высоту прямоугольника через тригонометрические функции, что я и сделал. Получился интересный эффект скручивания прямоугольника.

\textit{Демонстрация: } В общем можно все скомпилировать и запустить, все построено на базе glfw и glew. Но также прилагаю видео демонстрацию, чтобы вам особо с этим не заморачиваться(В видео почему-то кривая Безье отображается как азбука Морзе, возможно проблемы с записью. Отрисовка в режиме GL\_LINE\_STRIP дает спошную линию).

}
\newcommand{\thinks}{
  В своей первой лабе я начал понемногу вникать в pipeline работы с opengl, из-за недостаточного опыта, у меня получилась нерасширяемая архитектура приложения, поэтому для следующих лаб пришлось все переписывать заного с нуля, но для того чтобы сохранилась возможность скомпилировать и запустить первую лабу я переместил её исходники в include\_old для заголовочных файлов, src\_old для исходников. 

\\}
\usepackage{./styles/logStyle}
\begin{document}

\input{./src/titlepage.tex}
\input{./src/problem.tex}
\input{./src/thinks.tex}

\end{document}
